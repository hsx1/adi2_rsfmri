---
title: "Supplementary Information for 'Effects of bariatric surgery on functional connectivity of the reward and default mode network: a pre-registered analysis'"
author:
- Hannah Sophie Heinrichs* [1]
- Frauke Beyer* [1][2]
- Evelyn Medawar [1]
- Kristin Prehn [4][5]
- Jürgen Ordemann [8][9]
- Agnes Floel [4][5]
- A. Veronica Witte [3][1][2]
date: 1 Max-Planck-Institute for Human Cognitive and Brain Sciences, Leipzig \newline
  2 CRC 1052 "Obesity Mechanisms", Subproject A1, University of Leipzig \newline 3 Clinic of Cognitive Neurology, University Clinic Leipzig \newline 4 Department of Neurology and NeuroCure Clinical Research Center, Charité University Medicine, Berlin \newline 5 Department of Psychology, Medical School Hamburg, Hamburg \newline 6 Department of Neurology, University of Greifswald, Greifswald \newline 7 German Center for Neurodegenerative Diseases, Standort Rostock/Greifswald, Greifswald \newline 8 Center for Bariatric and Metabolic Surgery, Charité University Medicine, Berlin \newline 9 Center for Bariatric and Metabolic Surgery, Vivantes Clinic Spandau, Berlin
output:
  bookdown::pdf_book:
    fig_caption: yes
    always_allow_html: true
    number_sections: yes
    toc: no
    extra_dependencies: ["float","subfig"]
bibliography: "bibliography.bib"
editor_options:
  chunk_output_type: console
---

```{r "load packages", include=FALSE}
library(car) # version 3.0.9
library(plyr) # version 1.8.6
library(dplyr) # version 1.0.2
library(tidyr) # version 1.1.2
library(kableExtra) # version 1.2.1
library(ggplot2) # version 3.3.2
library(patchwork) # version 1.0.1; API for sequentially building up a plot (similar to gridExtra and cowplot)
library(cowplot)
library(RColorBrewer) # version 1.1.2
library(psych) # version 2.0.8

#library(lsr)
#library(haven)
library(wesanderson) # colour palette

library(lme4)

library(sjPlot) # only works for HTML output
library(texreg) # for works for Rmarkdown
library(knitr) # version 1.30

source('/data/gh_gr_agingandobesity_share/literature/methods/statistics/linear_models_course_rogermundry_2018/functions/glmm_stability.r')
source('/data/gh_gr_agingandobesity_share/literature/methods/statistics/linear_models_course_rogermundry_2018/functions/diagnostic_fcns.r')
```

```{r "knit setup", include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE) # fig.height=2, fig.width=4)
options(knitr.table.format = "latex")
options(knitr.kable.NA = ' ') # hide NA in tables
knitr::opts_chunk$set(fig.pos = "!ht", out.extra = "")
# set working directory of knit (RMarkdown) to directory of Rproj
```
\newpage

# Methods

## Sample
Table \@ref(tab:tableSample) shows the distribution of data points in the present rsfMRI study, for the bariatric surgery group (BARS) and the waiting-list control group (NBARS).

```{r "tableSample", echo=FALSE}
tableSample <- readRDS(file = "../report/tab/tableSample.rds")
tab <-
  knitr::kable(
    tableSample,
    row.names = TRUE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = "Distribution of data points at months after intervention")
tab
```

```{r tableDescr, include=FALSE}
# table for descriptive statistics
tableDescr <- readRDS(file = "../report/tab/tableDescr.rds")
knitr::kable(
    tableDescr,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = "BMI and logmFD of participants acquired in each condition and time point")
```

## Denoising Pipelines
We pre-registered two distinct denoising pipelines which were previously shown to efficiently remove motion artifacts in fMRI. In @Parkes_2018, ICA-AROMA provided an acceptable trade-off between the mitigation of motion-FC correlation and the introduction of a distance-dependence on motion-FC relationship. @Ciric_2017 showed that GSR is very efficient in removing the correlation of head motion and FC, and outperforms ICA-AROMA alone. Yet, it introduces spatial dependency and spurious correlations. 

### ICA-AROMA denoising pipeline   
As described in @pruim2015ica, the minimally preprocessed data underwent independent component analysis (ICA) using FSL's `melodic` and nuisance components were classified according to four spectral and spatial criteria. Finally, the timeseries of the  nuisance components were regressed from the raw rsfMRI timeseries non-aggressively.
As recommended in the original paper, we performed regression of WM and CSF signal on the ICA-AROMA result. We used CompCor to estimate 5 variance components from a combined WM and CSF mask, which was further eroded using `fslmaths -nan -thr 0.99 -ero -bin` [@Behzadi_2007;@Muschelli_2014]. After regression of these nuisance components from the data, we performed high-pass filtering at 0.01 Hz.

### Global Signal Regression (GSR) 
The global signal was derived from the average of all voxels in the brain mask. Then, we regressed WM and CSF CompCor components along with the GS from the ICA-AROMA rsfMRI data and high-pass filtered the resulting file as above.

## Quality Control
### Individual level rsfMRI QC
```{r carpetplot, out.width="50%", out.height="30%", fig.cap="Carpet plot for quality control", fig.subcap = c("Example 1 with strong amount of structured noise", "Example 2 with less amount of structured noise"), fig.show='hold',fig.align='center', echo=FALSE}
carpets=c("../report/carpetplotadi006fu2.jpeg","../report/carpetplotadi16fu.jpeg")
knitr::include_graphics(carpets)
```
On the individual level, we used `plot_carpet` from `niworkflows.viz.plots` to generate carpet plots which depict denoising quality. Figure \@ref(fig:carpetplot) shows an exemplary carpet plot with (from top to bottom): percent outliers defined by AFNI, mFD, `OutlierCount`, DVARS (spatial root mean square of the data after temporal differencing),voxelwise timeseries from minimally preprocessed, AROMA non-aggressive and aggressive denoising, CC and CC + GSR data (red: GM voxels, green: WM voxels, blue: ventricle, green: cerebellum). All carpet plots were visually checked and if there was still structured noise in the CC+GSR-denoised functional data (such as black/white stripes, signal dropout), the participant was given a rating of 1 in `QA residuals`, and checked again visually. No participant was excluded based on this visual inspection.

### Group level rsfMRI QC

As described in @Beyer_2020, there was a group-by-time interaction on mFD (see Figure \@ref(fig:figDvarsmFD), upper right panel). The intervention group reduced in head motion in the followup assessments compared to the control group. For this study, we further explored mFD and its relation to DVARS, the root mean square of the temporal change of the voxel-wise signal at each time point. DVARS measures volume-to-volume signal variation.
DVARS did not qualitatively differ between groups and time points, and the correlation of DVARS and mFD remained similar over time points (see Figure S2 in suppplements).
To further assess the confounding of head motion and FC, we evaluated mFD-FC relationships by computing a functional connectome based on the protocol by [@Ciric_2018]. We used the MNI coordinates of 246 cortical and subcortical spherical seed regions from @Power_2012 with 5mm radius in `NiftiSpheresMasker`, and calculated the Spearman rank correlation between these time series. Then, we calculated the distance-dependence of mFD-FC correlations by correlating the euclidean distance between nodes with the mFD-QC correlation.
```{r mFDFC, echo=FALSE}
res <- read.csv("../report/FDFCcorrelations.csv")
rownames(res) <- c("minimally processed", "AROMA", "AROMA + CC", "AROMA + CC + GSR")
colnames(res) <- c('mean mFD-FC', 'median mFD-FC', 'sig. conn.', 'sig. conn. BH', 'mean distance-mFDFC', 'p distance')
```
```{r tableQcfc, out.width="100%", echo=FALSE}
tab_Qcfc <-
  knitr::kable(
    round(res, 3),
    col.names = colnames(res),
    row.names = TRUE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = "Summary of quality metrics mean mFD-FC (mean Spearman's correlation of mFD and FC),median mFD-FC (median Spearman's correlation of mFD and FC), sig. conn. (number of significant connections), sig. conn. BH (number of FDR-corrected, significant connections), mean distance-mFDFC (mean Spearman's correlation of distance and mFD-FC correlation), p distance (p-value of distance dependency),  for minimal preprocessing,AROMA, AROMA+CC and AROMA+CC+GSR denoising pipelines over all data points"
  ) %>%
  column_spec(c(2:6), width = "1.8cm")
tab_Qcfc
```
In the minimally preprocessed data, mFD and FC between nodes were significantly positively correlated (mean Spearman's $r$ = `r round(res[1,1],2)`)(see Table \@ref(tab:tableQcfc)). This relationship was negatively associated with distance between nodes (mean Spearman's $r$ = `r round(res[1,5],2)`).  
Denoising pipelines (AROMA, AROMA+CC, AROMA+CC+GSR) gradually reduced the correlation of mFD and FC, and reduced the distance dependency. Contrary to previous reports, GSR did not exercabate mFD-FC distance dependency [@Power_2015]. Overall, AROMA+CC+GSR performed best, with almost no mFD-FC correlation (mean Spearman's $r$ = `r round(res[4,1],2)`), and minimal positive distance dependence (mean Spearman's $r$ = `r round(res[4,5],2)`)
In addition, for models showing a significant time-by-group interaction, we planned to perform a sensitivity analysis excluding the 10% data sets with highest mFD. 


```{r figDvarsmFD, out.width="100%", fig.cap='Summary of quality measures DVARS, mFD and their correlation', fig.show='hold',fig.align='center', echo=FALSE}
figList <- readRDS(file = "../report/fig/figDvarsmFDList.rds")
lay <- rbind(c(1,1,2,2),
             c(NA,3,3,NA))
figDvarsmFD <- gridExtra::grid.arrange(grobs = figList, layout_matrix = lay)
figDvarsmFD

```

```{r fighistograms,fig.cap="Histograms of FC-QC correlations for different denoising pipelines)", out.width="100%", fig.align = "default", echo=FALSE}
knitr::include_graphics("/data/pt_02161/Analysis/Project2_resting_state/seed-based/Second_level /code_and_manuscript/report/dp_aranged.jpeg")
```
Figure \@ref(fig:fighistograms) shows the distribution of FC-QC correlations for minimally preprocessed, AROMA, AROMA+CC and AROMA+CC+GSR preprocessed data. With more denoising, there is a decreasing number of high correlations between FC and the measure of head motion, supporting the positive effect of denoising.

```{r figtSNR,fig.cap="Lower tSNR in the region of interest NAcc versus precuneus used for seed-based connectivity (shown are all 101 timepoints)", out.width="100%", fig.align = "center", eval=TRUE}
tsnr <- "../report/tsnr.pdf"
knitr::include_graphics(tsnr)
```

## DMN and RN Networks
Figure \@ref(fig:figNetworks) shows the DMN and reward network average maps which we used for extracting aggregated FC values. Both networks included the typically described brain regions (i.e. medial prefrontal cortex, parietal lobules and posterior hippocampus for the DMN, and anterior cingulate, right amygdala and ventromedial-prefrontal cortex for the reward network).
Yet, the reward network was less pronounced (overall lower T-values) and less symmetric (no significant connectivity with left amygdala), which might be due to lower SNR in the seeded brain region (see \@ref(fig:figtSNR)).
Unthresholded maps for the t-tests of the DMN and reward network (which were used for data aggregation) are on Neurovault.
```{r figNetworks, echo=FALSE, out.width="50%", out.height="30%", fig.cap="Resting state networks based on AROMA+CC+GSR input data, one-sample t-tests adjusting for age and sex over all time points and participants with bootstrapped clusterwise inference (FWE-corrected $p < 0.05$). Legend denotes empirical Z-values.", fig.subcap = c("DMN seeded from precuneus", "Reward network seeded from Nucleus Accumbens", "tSNR differences between regions"),fig.show='hold',fig.align='center'}

networks = c("../report/fig/DMN_thresholded_for_clusterFWE005.pdf",
             "../report/fig/Rew_thresholded_for_clusterFWE005.pdf")
knitr::include_graphics(networks)
```


## Design
```{r figDesignmatrix, fig.align = 'center', fig.ncol = 2, out.width = "100%",  fig.cap="Design matrices of time-by-group model with time as categorial factor. N, NBARS; B, BARS; numbers indicate month of measurement since beginning, 0 indicates baseline(pre-surgery measurement, 6 and 12 indicate months after baseline/surgery.", echo=FALSE}
DesignMatricesList <- readRDS(file = "../report/fig/DesignMatricesList.rds")
DesignMatricesList$plotA
#gridExtra::grid.arrange(plotA, plotB, nrow=1)
```

# Results

## Confirmatory Analysis

```{r "GT2tpagesexmFDBMIblNaccgsrTimeDeact", fig.cap="Main effect of time: Negative Association of FC between NAcc and this cluster in lateral parietal cortex, adjusted for age, sex, avgFD, and baseline BMI in AROMA+CC+GSR preprocessed data. Legend denotes empirical Z-values.", fig.hold=TRUE, out.width = "50%", fig.align="center"}
knitr::include_graphics(c("../report/fig/GroupTime2tp_NACCgsr_time_deact.pdf"))
```

```{r "GT2tpagesexmFDBMIblPCCgsrTimeDeact", fig.cap="Main effect of time: Negative Association of FC between PCC/precuneus and this cluster in ACC, adjusted for age, sex, avgFD, and baseline BMI in AROMA+CC+GSR preprocessed data. Legend denotes empirical Z-values.", fig.hold=TRUE, out.width = "50%", fig.align="center"}
knitr::include_graphics(c("../report/fig/GroupTime2tp_PCCgsr_time_deact.pdf"))
```

## Aggregated FC: confirmatory analysis of an interaction effect of group and time 
```{r load agg FC data and prepare, echo=FALSE}
final_FC <- read.csv("../report/final_FC.csv")
final_FC$group_factor=relevel(final_FC$group_factor, "KG")
```


```{r identify outliers in these plots, eval=FALSE}
### SUMMARY: all in all there is no reason to exclude the subjects with outlying values in mean Rew/DMN connectivity
final_FC[final_FC$mean_DMN_conn< 0.1, c("mean_DMN_conn", "mean_Rew_conn", "subj.ID_tp", "subj.ID", "tp", "condition")]
#ADI003_fu2 & ADI041_fu -> do not have particularly high head motion
#plot(final_FC$mean_DMN_conn, final_FC$logmFD) -> see two left points
#carpet plots look ok, brain maps of DMN look okish, though not pronounced
#ADI003_fu2 & ADI041 fu: FS issues (Final_score:3, corrected)
qa_info=read.csv("/data/p_02161/ADI_studie/metadata/final_sample_MRI_QA_info.csv")
qa_info[qa_info$subj.ID=="ADI003"&qa_info$tp=="fu2",]
qa_info[qa_info$subj.ID=="ADI041"&qa_info$tp=="fu",]

final_FC[final_FC$mean_Rew_conn>0.3, c("mean_Rew_conn", "subj.ID_tp", "subj.ID", "tp", "condition")]
plot(final_FC$mean_Rew_conn, final_FC$logmFD)
#-> do not have particularly high head motion (two right points)
#ADI069_bl
#nifti looks ok, carpet plot shows lot of stripes.
qa_info[qa_info$subj.ID=="ADI069"&qa_info$tp=="bl",]
#FS issues, parts of skull included
#ADI111_fu2
#nifti looks ok, some residual carpet plot noise
qa_info[qa_info$subj.ID=="ADI111"&qa_info$tp=="fu2",]
#no FS issues
```


### Reward network 
**Two time points, without adjustments (Model CA1) **

```{r calc rew two tp, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~ tp*group_factor + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
R0 = lme4::lmer(mean_Rew_conn ~ tp + group_factor +  (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
anvRew2tp=anova(R1,R0)
```

```{r qa check Rew model age,sex, eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary
```

```{r Rew2tp results, caption="Interaction of group and time on reward network connectivity for two time points", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Group BARS",
    "Timepoint x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Two timepoints, adjusted for age, sex and average logmFD (Model CA2)**

```{r calc rew two tp adjusted 2, fig.cap="Two timepoints, adjusted for age, sex and average logmFD (Model CA2)", eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
R0 = lme4::lmer(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
anvRew2tpadj=anova(R1,R0)
```

```{r qa check Rew model age,sex,mFD,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex + mean.logmFD, data=final_FC)
vif_res=vif(test_vif)
```

```{r Rew2tpadj2 results, caption="Interaction of group and time on reward network connectivity for two time points, adjusted for age, sex and average of logmFD", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 7, 4, 5, 6),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "Timepoint x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Two timepoints, adjusted for age, sex, average of logmFD and baseline BMI (Model CA3)**

```{r calc rew two tp adjusted 3, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + BMI_BLi + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
R0 = lme4::lmer(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +BMI_BLi + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
anvRew2tpadj=anova(R1,R0)
```

```{r qa check Rew model age,sex,mFD,baselineBMI,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +  BMI_BLi, data=final_FC)
vif_res=vif(test_vif)
```

```{r Rew2tpadj3 results, caption="Interaction of group and time on reward network connectivity for two time points, adjusted for age, sex, average of logmFD and baseline BMI", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 8, 4, 5, 6,7),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "baseline BMI",
    "Timepoint x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Three time points, without adjustments (Model CA1)**

```{r calc rew three tp, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~ tp*group_factor + (1|subj.ID), data=final_FC)
R0 = lme4::lmer(mean_Rew_conn ~ tp + group_factor +  (1|subj.ID), data=final_FC)
anvRew2tp=anova(R1,R0)
```
```{r qa check Rew model age,sex three timepoints, eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary
```

```{r Rew3tp results, caption="Interaction of group and time on reward network connectivity for two time points", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Timepoint FU2",
    "Group BARS",
    "Timepoint FU x Group", 
    "Timepoint FU2 x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Three timepoints, adjusted for age, sex and average logmFD (Model CA2)**

```{r calc rew three tp adjusted 2, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + (1|subj.ID), data=final_FC)
R0 = lme4::lmer(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +(1|subj.ID), data=final_FC)
anvRew2tpadj=anova(R1,R0)
```

```{r qa check Rew model age,sex,mFD, three timepoints,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex + mean.logmFD, data=final_FC)
vif_res=vif(test_vif)
```

```{r Rew3tpadj 2 results, caption="Interaction of group and time on reward network connectivity for two time points, adjusted for age, sex and average of logmFD", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 4, 8, 9, 5, 6, 7),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Timepoint FU2",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "Timepoint FU x Group", 
    "Timepoint FU2 x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Three timepoints, adjusted for age, sex, average of logmFD and baseline BMI (Model CA3)**

```{r calc rew three tp adjusted 3, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + BMI_BLi + (1|subj.ID), data=final_FC)
R0 = lme4::lmer(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +BMI_BLi + (1|subj.ID), data=final_FC)
anvRew3tpadj=anova(R1,R0)
```

```{r qa check Rew model age,sex,mFD,baselineBMI, three timepoints,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_Rew_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +  BMI.bl, data=final_FC)
vif_res=vif(test_vif)
```

```{r Rew3tpadj 3 results, caption="Interaction of group and time on reward network connectivity for two time points, adjusted for age, sex, average of logmFD and baseline BMI", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 4,9,10, 5, 6, 7,8),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Timepoint FU2",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "baseline BMI",
    "Timepoint FU x Group", 
    "Timepoint FU2 x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

```{r Rew conn over three timepoints, echo=FALSE}
fig_Rewconn <- readRDS(file = "../report/fig/figRewconn.rds")
fig_Rewconn
```


### DMN 
**Two time points, without adjustments (Model CA1)**

```{r calc rew two tp DMN, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~ tp*group_factor + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
R0 = lme4::lmer(mean_DMN_conn ~ tp + group_factor +  (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
anvDMN2tp=anova(R1,R0)
```
```{r qa check DMN model age,sex, eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary
```

```{r DMN2tp results, caption="Interaction of group and time on DMN connectivity for two time points", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Group BARS",
    "Timepoint x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Two timepoints, adjusted for age, sex and average logmFD (Model CA2)**

```{r calc DMN two tp adjusted 2, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
R0 = lme4::lmer(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +(1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
anvDMN2tpadj=anova(R1,R0)
```

```{r qa check DMN model age,sex,mFD,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex + logmFD, data=final_FC)
vif_res=vif(test_vif)
```

```{r DMN2tpadj2 results, caption="Interaction of group and time on DMN connectivity for two time points, adjusted for age, sex and average of logmFD", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 7, 4, 5, 6),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "Timepoint x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Two timepoints, adjusted for age, sex, average of logmFD and baseline BMI (Model CA3)**

```{r calc DMN two tp adjusted 3, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + BMI_BLi + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
R0 = lme4::lmer(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +BMI_BLi + (1|subj.ID), data=final_FC[final_FC$tp!="fu2",])
anvDMN2tpadj=anova(R1,R0)
```

```{r qa check DMN model age,sex,mFD,baselineBMI,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +  BMI.bl, data=final_FC)
vif_res=vif(test_vif)
```

```{r DMN2tpadj3 results, caption="Interaction of group and time on DMN connectivity for two time points, adjusted for age, sex, average of logmFD and baseline BMI", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 8, 4, 5, 6,7),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "baseline BMI",
    "Timepoint x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Three time points, without adjustments (Model CA1)**

```{r calc DMN three tp, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~ tp*group_factor + (1|subj.ID), data=final_FC)
R0 = lme4::lmer(mean_DMN_conn ~ tp + group_factor +  (1|subj.ID), data=final_FC)
anvDMN3tp=anova(R1,R0)
```
```{r qa check DMN model age,sex three timepoints, eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary
```

```{r DMN3tp results, caption="Interaction of group and time on DMN connectivity for two time points", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Timepoint FU2",
    "Group BARS",
    "Timepoint FU x Group", 
    "Timepoint FU2 x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Three timepoints, adjusted for age, sex and average logmFD (Model CA2)**

```{r calc DMN three tp adjusted 2, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + (1|subj.ID), data=final_FC)
R0 = lme4::lmer(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +(1|subj.ID), data=final_FC)
anvDMN3tpadj=anova(R1,R0)
```

```{r qa check DMN model age,sex,mFD, three timepoints,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary

test_vif=lm(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex + logmFD, data=final_FC)
vif_res=vif(test_vif)
```

```{r DMN3tpadj 2 results, caption="Interaction of group and time on DMN connectivity for two time points, adjusted for age, sex and average of logmFD", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 4, 8, 9, 5, 6, 7),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Timepoint FU2",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "Timepoint FU x Group", 
    "Timepoint FU2 x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Three timepoints, adjusted for age, sex, average of logmFD and baseline BMI (Model CA3)**
```{r calc DMN three tp adjusted 3, eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~ tp*group_factor + Age_BL + Sex + mean.logmFD + BMI_BLi + (1|subj.ID), data=final_FC)
R0 = lme4::lmer(mean_DMN_conn ~ tp + group_factor + Age_BL + Sex +mean.logmFD +BMI_BLi + (1|subj.ID), data=final_FC)
anvDMN3tpadj=anova(R1,R0)
```

```{r qa check DMN model age,sex,mFD,baselineBMI, three timepoints,eval=FALSE}
diagnostics.plot(R0)
ranef.diagn.plot(R0)

m.stab=glmm.model.stab(model.res = R0)
#to check whether there were any converge issues:
table(m.stab$detailed$warnings)
m.stab$summary
```

```{r DMN3tpadj 3 results, caption="Interaction of group and time on DMN connectivity for two time points, adjusted for age, sex, average of logmFD and baseline BMI", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R0, R1),
  reorder.coef = c(1, 2, 3, 4, 9, 10, 5, 6, 7,8),
  custom.coef.names = c(
    "Intercept (BL, NBARS)",
    "Timepoint FU",
    "Timepoint FU2",
    "Group BARS",
    "Age",
    "Sex",
    "av logmFD",
    "baseline BMI",
    "Timepoint FU x Group", 
    "Timepoint FU2 x Group"
  ),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

```{r DMN conn over three timepoints, echo=FALSE}
fig_DMNconn <- readRDS(file = "../report/fig/figDMNconn.rds")
fig_DMNconn
```


## Exploratory Analyses: Effects of average and change BMI on FC
### Reward network

**Model EA1 (without adjustment) and EA2 (adjusting for logmFD)**
```{r "reward model, mean, change BMI", eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~  mean.BMI + within.BMI + Age_BL + Sex  + (1|subj.ID), data=final_FC)
R01 = lme4::lmer(mean_Rew_conn ~ mean.BMI +  Age_BL + Sex +(1|subj.ID), data=final_FC)
R02 = lme4::lmer(mean_Rew_conn ~ within.BMI +  Age_BL + Sex +(1|subj.ID), data=final_FC)
anvwithinBMI=anova(R1,R01)
anvmeanBMI=anova(R1,R02)
p_meanBMI=anvmeanBMI$`Pr(>Chisq)`[2]

R11 = lme4::lmer(mean_Rew_conn ~  mean.BMI + within.BMI + Age_BL + Sex + logmFD + (1|subj.ID), data=final_FC)
R12a = lme4::lmer(mean_Rew_conn ~ within.BMI +  Age_BL + Sex + logmFD+(1|subj.ID), data=final_FC)
anvmeanBMI_adjmFD=anova(R11,R12a)
```

```{r reward model_BMIFD results, caption="Model 2a and 2b for aggregated reward network FC", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R1, R11),
  custom.coef.names = c("Intercept", "average BMI", "change BMI", "Age", "Sex", "logmFD"),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```


**Model EA 3 (adjusting for average and change in logmFD)**
```{r "reward model mean+change of BMI+logmFD", eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_Rew_conn ~  mean.BMI + within.BMI + mean.logmFD + within.logmFD + Age_BL + Sex  + (1|subj.ID), data=final_FC)
R01 = lme4::lmer(mean_Rew_conn ~ mean.BMI + mean.logmFD + within.logmFD + Age_BL + Sex +(1|subj.ID), data=final_FC)
R02 = lme4::lmer(mean_Rew_conn ~ within.BMI + mean.logmFD + within.logmFD +  Age_BL + Sex +(1|subj.ID), data=final_FC)
R03 = lme4::lmer(mean_Rew_conn ~ mean.BMI  + within.BMI +  within.logmFD +  Age_BL + Sex +(1|subj.ID), data=final_FC)
R03 = lme4::lmer(mean_Rew_conn ~ mean.BMI  + within.BMI +  mean.logmFD +  Age_BL + Sex +(1|subj.ID), data=final_FC)
anvwithinBMI=anova(R1,R01)
anvmeanBMI=anova(R1,R02)
anvmeanFD=anova(R1,R03)
anvwithinFD=anova(R1,R03)

p_mean_BMI=anvmeanBMI$`Pr(>Chisq)`
```

```{r reward_BMI_splitFD results, caption="Model EA 2.3 for aggregated reward network FC", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(list(R1), custom.coef.names=c("Intercept", "average BMI", "change BMI", "average logmFD", "change logmFD", "Age", "Sex"), custom.model.names = "R1", float.pos = "h!",  center = TRUE, digits = 3, leading.zero = FALSE, single.row = TRUE, include.adjrs = FALSE, include.bic = FALSE, table = FALSE, use.packages = TRUE)
```

### DMN

**Model EA1 (without adjustment) and EA2 (adjusting for logmFD)**
```{r "DMN model, mean, change BMI", eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~  mean.BMI + within.BMI + Age_BL + Sex  + (1|subj.ID), data=final_FC)
R01 = lme4::lmer(mean_DMN_conn ~ mean.BMI +  Age_BL + Sex +(1|subj.ID), data=final_FC)
R02 = lme4::lmer(mean_DMN_conn ~ within.BMI +  Age_BL + Sex +(1|subj.ID), data=final_FC)
anvwithinBMI=anova(R1,R01)
anvmeanBMI=anova(R1,R02)
p_meanBMI=anvmeanBMI$`Pr(>Chisq)`[2]

R11 = lme4::lmer(mean_DMN_conn ~  mean.BMI + within.BMI + Age_BL + Sex + logmFD + (1|subj.ID), data=final_FC)
R12a = lme4::lmer(mean_DMN_conn ~ within.BMI +  Age_BL + Sex + logmFD+(1|subj.ID), data=final_FC)
anvmeanBMI_adjmFD=anova(R11,R12a)
```

```{r DMN_BMIFD results, caption="Model 2.1 and 2.2 for aggregated DMN FC", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(
  list(R1, R11),
  custom.coef.names = c("Intercept", "average BMI", "change BMI", "Age", "Sex", "logmFD"),
  custom.model.names = c("R0", "R1"),
  float.pos = "h!",
  center = TRUE,
  digits = 3,
  leading.zero = FALSE,
  single.row = TRUE,
  include.adjrs = FALSE,
  include.bic = FALSE,
  table = FALSE,
  use.packages = TRUE
)
```

**Model EA3 (adjusting for average and change in logmFD)**
```{r "DMN model mean+change of BMI+logmFD", eval = TRUE, echo = FALSE}
R1 = lme4::lmer(mean_DMN_conn ~  mean.BMI + within.BMI + mean.logmFD + within.logmFD + Age_BL + Sex  + (1|subj.ID), data=final_FC)
R01 = lme4::lmer(mean_DMN_conn ~ mean.BMI + mean.logmFD + within.logmFD + Age_BL + Sex +(1|subj.ID), data=final_FC)
R02 = lme4::lmer(mean_DMN_conn ~ within.BMI + mean.logmFD + within.logmFD +  Age_BL + Sex +(1|subj.ID), data=final_FC)
R03 = lme4::lmer(mean_DMN_conn ~ mean.BMI  + within.BMI +  within.logmFD +  Age_BL + Sex +(1|subj.ID), data=final_FC)
R03 = lme4::lmer(mean_DMN_conn ~ mean.BMI  + within.BMI +  mean.logmFD +  Age_BL + Sex +(1|subj.ID), data=final_FC)
anvwithinBMI=anova(R1,R01)
anvmeanBMI=anova(R1,R02)
anvmeanFD=anova(R1,R03)
anvwithinFD=anova(R1,R03)

p_mean_BMI=anvmeanBMI$`Pr(>Chisq)`
```

```{r DMN_BMI_splitFD results, caption="Model 2.3 for aggregated DMN FC", results="asis", echo=FALSE}
#tab_model(R1,R0)
texreg(list(R1), custom.coef.names=c("Intercept", "average BMI", "change BMI", "average logmFD", "change logmFD", "Age", "Sex"), custom.model.names = "R1", float.pos = "h!",  center = TRUE, digits = 3, leading.zero = FALSE, single.row = TRUE, include.adjrs = FALSE, include.bic = FALSE, table = FALSE, use.packages = TRUE)
```

\newpage
### Anatomical Labelling for models

Find in the detailed Output of the SPM Anatomy toolbox, version 2.2c. For Clusters without any labels, the toolbox was unable to assign any grey matter area. Models evaluated were model 2a estimating the effects of average BMI and change in BMI, adjusting for age and sex (Table \@ref(tab:Tab2a)), then model 2b where we additionally adjusted for logmFD (Table \@ref(tab:Tab2b)), and model 2c estimating the effects of average BMI and BMI variability as well as average logmFD and change in logmFD, adjusting for age and sex (Table \@ref(tab:Tab2cfirst) to Table \@ref(tab:Tab2clast)). Last, the FD model estimating the unique effects of average logmFD and change in logmFD when adjusting for age and sex was evaluated (Table \@ref(tab:TabFDfirst) and Table \@ref(tab:TabFDlast)).


```{r, include = FALSE}
ToolboxOutputList <- readRDS(file = "../report/tab/DetailedFCTableList.rds")
TableList_colname <- kableExtra::linebreak(c("Cluster","Number of voxels\nin cluster","\\% of cluster\nvolume assigned", "Hemisphere","Area","\\% of area overlap\nwith cluster"))

TableList <- list()
for (i in 1:length(ToolboxOutputList$EntryList)){
  TableList[[i]] <-
    ToolboxOutputList$EntryList[[i]] %>%
    knitr::kable(
      escape = FALSE,     # use font spec of latex with kableExtra
      col.names = TableList_colname,
      row.names = FALSE,
      format = "latex",
      booktabs = T,
      linesep = "",      # disable "\\addlinespace" at every 5th line
      #label = name_model[i],
      caption = ToolboxOutputList$CaptionList[i],
    ) %>%
    kableExtra::kable_styling(latex_options = c('scale_down'))
}
```

```{r Tab2a, echo=FALSE}
i = 2
ToolboxOutputList$EntryList[[i]] %>%
  knitr::kable(
    escape = FALSE,
    col.names = TableList_colname,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = ToolboxOutputList$CaptionList[i],
  ) %>%
  kableExtra::kable_styling(latex_options = c('scale_down')) 
```

```{r "Tab2b", echo=FALSE}
i = 1
ToolboxOutputList$EntryList[[i]] %>%
  knitr::kable(
    escape = FALSE,
    col.names = TableList_colname,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = ToolboxOutputList$CaptionList[i],
  ) %>%
  kableExtra::kable_styling(latex_options = c('scale_down')) 
```

```{r "Tab2cfirst", echo=FALSE}
i = 3
ToolboxOutputList$EntryList[[i]] %>%
  knitr::kable(
    escape = FALSE,
    col.names = TableList_colname,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = ToolboxOutputList$CaptionList[i],
  ) %>%
  kableExtra::kable_styling(latex_options = c('scale_down')) 
```

```{r, echo=FALSE}
TableList[[4]]
TableList[[5]]
TableList[[6]]
```

```{r "Tab2clast", echo=FALSE}
i = 7
ToolboxOutputList$EntryList[[i]] %>%
  knitr::kable(
    escape = FALSE,
    col.names = TableList_colname,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = ToolboxOutputList$CaptionList[i],
  ) %>%
  kableExtra::kable_styling(latex_options = c('scale_down')) 
```

```{r "TabFDfirst", echo=FALSE}
i = 8
ToolboxOutputList$EntryList[[i]] %>%
  knitr::kable(
    escape = FALSE,
    col.names = TableList_colname,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = ToolboxOutputList$CaptionList[i],
  ) %>%
  kableExtra::kable_styling(latex_options = c('scale_down')) 
```

```{r "TabFDlast", echo=FALSE}
i = 8
ToolboxOutputList$EntryList[[i]] %>%
  knitr::kable(
    escape = FALSE,
    col.names = TableList_colname,
    row.names = FALSE,
    format = "latex",
    booktabs = T,
    linesep = "",
    caption = ToolboxOutputList$CaptionList[i],
  ) %>%
  kableExtra::kable_styling(latex_options = c('scale_down'))
    
```
\newpage
### References